const fs = require("fs");
const path = require("path");

const vulnerabilitiesDir = path.join(__dirname, "../vulnerabilities");
const newVulnerabilityDir = path.join(__dirname, "../input");
const newVulnerabilityEmptyTemplate = {"package_name":"","patch_versions":[],"vulnerable_ranges":[],"cwe":[],"tldr":"","doest_this_affect_me":"","how_to_fix":"","reporter":"","vulnerable_to":"","related_cve_id":"","language":"","severity_class":"","aikido_score":0,"changelog":"","package_name_alias":null,"package_wildcard_ends_in":null,"package_wildcard_contains":null,"extra_specific_non_vulnerable_versions":null,"unaffected_distros":null,"simplify_version_if_has_patch_part":false};

// Helper functions to load vulnerabilities
function readAllJsonFiles() {
  const vulnerabilities = {};
  const files = fs.readdirSync(vulnerabilitiesDir);
  const newFiles = fs.readdirSync(newVulnerabilityDir);

  files.forEach((file) => {
    if (file.endsWith(".json")) {
      const filePath = path.join(vulnerabilitiesDir, file);
      const data = JSON.parse(fs.readFileSync(filePath, "utf-8"));
      vulnerabilities[path.basename(file, ".json")] = data;
    }
  });

  // assert only one file in newFiles (called new.json)
  expect(newFiles.length).toBe(1);
  expect(newFiles[0]).toBe("new.json");

  const newVulnerability = JSON.parse(fs.readFileSync(path.join(newVulnerabilityDir, "new.json"), "utf-8"));

  if(JSON.stringify(newVulnerability) !== JSON.stringify(newVulnerabilityEmptyTemplate)){
    // ok changes made to new.json -> make sure to test it as well
    vulnerabilities["new"] = newVulnerability;
  }

  return vulnerabilities;
}

function listAllLanguages(vulnerabilities) {
  return [...new Set(Object.values(vulnerabilities).map((v) => v.language))];
}

function listAllIds(vulnerabilities) {
  return Object.keys(vulnerabilities)
}

// Tests
describe("Valid Vulnerabilities", () => {
  let vulnerabilities;

  beforeAll(() => {
    vulnerabilities = readAllJsonFiles();
  });

  test("All vulnerabilities are valid", () => {
    for (const [filename, vuln] of Object.entries(vulnerabilities)) {
      if(filename !== 'new'){
        expect(filename.startsWith("AIKIDO-")).toBe(true);
        expect(typeof vuln.published).toBe("string");
        expect(typeof vuln.last_modified).toBe("string");
        expect(vuln.published).toMatch(/^\d{4}-\d{2}-\d{2}$/);
        expect(vuln.last_modified).toMatch(/^\d{4}-\d{2}-\d{2}$/);

        const expectedKeys = [...Object.keys(newVulnerabilityEmptyTemplate), 'published', 'last_modified'];

        expect(Object.keys(vuln).sort().join(',')).toBe(expectedKeys.sort().join(','));
      }else{
        expect(Object.keys(vuln).sort().join(',')).toBe(Object.keys(newVulnerabilityEmptyTemplate).sort().join(','));
      }

      expect(vuln.package_name).not.toBe("");
      expect(Array.isArray(vuln.patch_versions)).toBe(true);
      expect(Array.isArray(vuln.cwe)).toBe(true);
      expect(typeof vuln.tldr).toBe("string");
      expect(typeof vuln.doest_this_affect_me).toBe("string");
      expect(typeof vuln.how_to_fix).toBe("string");
      expect(typeof vuln.vulnerable_to).toBe("string");
      expect(typeof vuln.related_cve_id).toBe("string");
      expect(typeof vuln.language).toBe("string");
      expect(typeof vuln.severity_class).toBe("string");
      expect(typeof vuln.aikido_score).toBe("number");
      expect(typeof vuln.changelog).toBe("string");

      if (vuln.package_name_alias !== null) {
        expect(typeof vuln.package_name_alias).toBe("string");
      }

      if (vuln.package_wildcard_contains !== null) {
        expect(typeof vuln.package_wildcard_contains).toBe("string");
      }

      if (vuln.extra_specific_non_vulnerable_versions !== null) {
        expect(Array.isArray(vuln.extra_specific_non_vulnerable_versions)).toBe(
          true
        );
      }

      if (vuln.unaffected_distros !== null) {
        expect(Array.isArray(vuln.unaffected_distros)).toBe(true);
      }

      if (vuln.simplify_version_if_has_patch_part !== null) {
        expect(typeof vuln.simplify_version_if_has_patch_part).toBe("boolean");
      }

      if (vuln.reporter !== null) {
        expect(typeof vuln.reporter).toBe("string");
      }

      if (vuln.vulnerable_ranges !== null) {
        if (!Array.isArray(vuln.vulnerable_ranges)) {
          expect(vuln.vulnerable_ranges).toBe("*");
        } else {
          expect(Array.isArray(vuln.vulnerable_ranges)).toBe(true);
        }
      }
    }
  });

  test("Valid languages", () => {
    const validLanguages = [
      "js",
      "python",
      "ruby",
      "java",
      "php",
      "go",
      "dotnet",
      "swift",
      "rust",
      "dart",
      "elixir",
      "os",
      "r",
      "c++",
    ];

    const languages = listAllLanguages(vulnerabilities);
    languages.forEach((language) => {
      expect(validLanguages).toContain(language.toLowerCase());
    });
  });

  test("Valid severity_class", () => {
    const severity_classes = ["LOW", "MEDIUM", "HIGH", "CRITICAL"];
    for (const [filename, vuln] of Object.entries(vulnerabilities)) {
      expect(severity_classes).toContain(vuln.severity_class);
    }
  });

  test("No duplicate vulnerability IDs", () => {
    const ids = listAllIds(vulnerabilities);
    expect(new Set(ids).size).toBe(ids.length);
  });

  test("PHP vulnerabilities do not start with '@'", () => {
    for (const vuln of Object.values(vulnerabilities)) {
      if (vuln.language.toLowerCase() !== "js") {
        expect(vuln.package_name.startsWith("@")).toBe(false);
      }
    }
  });
});
