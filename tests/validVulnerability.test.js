const fs = require("fs");
const path = require("path");

const vulnerabilitiesDir = path.join(__dirname, "../vulnerabilities");
const newVulnerabilityDir = path.join(__dirname, "../input");
const newVulnerabilityEmptyTemplate = {"package_name":"","patch_versions":[],"vulnerable_ranges":[],"cwe":[],"tldr":"","doest_this_affect_me":"","how_to_fix":"","vulnerable_to":"","related_cve_id":"","language":"","severity_class":"","aikido_score":0,"changelog":""};

const optionalFields = [
    'reporter',
    'package_name_alias',
    'package_wildcard_ends_in',
    'package_wildcard_contains',
    'extra_specific_non_vulnerable_versions',
    'unaffected_distros',
    'simplify_version_if_has_patch_part',
    'allow_patch_part_transformation',
    'published',
    'last_modified',
    'only_for_path_ends_with',
    'org_name',
    'version_type_hint',
]
const requiredFields = [
    'package_name',
    'patch_versions',
    'vulnerable_ranges',
    'cwe',
    'tldr',
    'doest_this_affect_me',
    'how_to_fix',
    'vulnerable_to',
    'related_cve_id',
    'language',
    'severity_class',
    'aikido_score',
    'changelog',
]

// Helper functions to load vulnerabilities
function readAllJsonFiles() {
  const vulnerabilities = {};
  const files = fs.readdirSync(vulnerabilitiesDir);
  const newFiles = fs.readdirSync(newVulnerabilityDir);

  files.forEach((file) => {
    if (file.endsWith(".json")) {
      const filePath = path.join(vulnerabilitiesDir, file);
      const data = JSON.parse(fs.readFileSync(filePath, "utf-8"));
      vulnerabilities[path.basename(file, ".json")] = data;
    }
  });

  // assert only one file in newFiles (called new.json)
  expect(newFiles.length).toBe(1);
  expect(newFiles[0]).toBe("new.json");

  const newVulnerability = JSON.parse(fs.readFileSync(path.join(newVulnerabilityDir, "new.json"), "utf-8"));

  assertValidFields(newVulnerability);

  if(JSON.stringify(newVulnerability) !== JSON.stringify(newVulnerabilityEmptyTemplate)){
    // ok changes made to new.json -> make sure to test it as well
    vulnerabilities["new"] = newVulnerability;
  }

  return vulnerabilities;
}

function listAllLanguages(vulnerabilities) {
  return [...new Set(Object.values(vulnerabilities).map((v) => v.language))];
}

function listAllIds(vulnerabilities) {
  return Object.keys(vulnerabilities)
}

function assertValidFields(vuln) {
  // make sure all required fields are present
  for (const requiredField of requiredFields) {
    expect(vuln[requiredField]).toBeDefined();
  }

  // make sure no unsupported fields are introduced
  for (const newField of Object.keys(vuln)) {
    const possibleFields = [...requiredFields, ...optionalFields];
    expect(possibleFields).toContain(newField);
  }
}

function version_bits(version) {
  version = version.replace(/(\d+)([^\d\.]+)/, '$1.$2');
  version = version.replace(/([^\d\.]+)(\d+)/, '$1.$2');
  var parts = version.split('.'),
      rmap = {
        'rc' : -1,
        'pre' : -2,
        'beta' : -3,
        'b' : -3,
        'alpha' : -4,
        'a' : -4,
        'post' : 1,
      },
      v, n;

  var bits = [];
  for (var i = 0; i < parts.length; ++i) {
    v = parts[i];

    n = parseInt(v, 10);
    if ( isNaN(n) ) {
      n = rmap[v] || -1;
    }
    bits.push(n);
  }
  return bits;
}

function version_compare(version1, version2) {
  var v1parts = version_bits(version1);
  var v2parts = version_bits(version2);
  var v2, v1;

  for (var i = 0; i < Math.max(v1parts.length, v2parts.length); ++i) {
    v1 = v1parts[i] || 0;
    v2 = v2parts[i] || 0;

    if (v2 > v1) {
      return 1;
    }
    else if (v1 > v2) {
      return -1;
    }
  }

  return 0;
}

function isVersionOutsideRange(version, range_start, range_end) {
  return (version_compare(version, range_start) === -1 && version_compare(version, range_end) === -1) ||
      (version_compare(version, range_start) === 1 && version_compare(version, range_end) === 1);
}

// Tests
describe("Valid Vulnerabilities", () => {
  let vulnerabilities;

  beforeAll(() => {
    vulnerabilities = readAllJsonFiles();
  });

  test("All vulnerabilities are valid", () => {
    for (const [filename, vuln] of Object.entries(vulnerabilities)) {
      if(filename !== 'new'){
        expect(filename.startsWith("AIKIDO-")).toBe(true);
        expect(typeof vuln.published).toBe("string");
        expect(typeof vuln.last_modified).toBe("string");
        expect(vuln.published).toMatch(/^\d{4}-\d{2}-\d{2}$/);
        expect(vuln.last_modified).toMatch(/^\d{4}-\d{2}-\d{2}$/);
      }
      assertValidFields(vuln);

      expect(vuln.package_name).not.toBe("");
      expect(Array.isArray(vuln.patch_versions)).toBe(true);
      expect(Array.isArray(vuln.cwe)).toBe(true);
      expect(typeof vuln.tldr).toBe("string");
      expect(typeof vuln.doest_this_affect_me).toBe("string");
      expect(typeof vuln.how_to_fix).toBe("string");
      expect(typeof vuln.vulnerable_to).toBe("string");
      expect(typeof vuln.related_cve_id).toBe("string");
      expect(typeof vuln.language).toBe("string");
      expect(typeof vuln.severity_class).toBe("string");
      expect(typeof vuln.aikido_score).toBe("number");
      expect(vuln.aikido_score).toBeGreaterThanOrEqual(0);
      expect(vuln.aikido_score).toBeLessThanOrEqual(100);
      expect(typeof vuln.changelog).toBe("string");

      if (vuln.package_name_alias !== undefined && vuln.package_name_alias !== null) {
        expect(typeof vuln.package_name_alias).toBe("string");
      }

      if (vuln.package_wildcard_contains !== undefined && vuln.package_wildcard_contains !== null) {
        expect(typeof vuln.package_wildcard_contains).toBe("string");
        expect(vuln.package_wildcard_contains.length).toBeGreaterThan(8);
        expect(vuln.package_wildcard_contains).toMatch(/[^a-zA-Z0-9]/)
      }

      if (vuln.extra_specific_non_vulnerable_versions !== undefined && vuln.extra_specific_non_vulnerable_versions !== null) {
        expect(Array.isArray(vuln.extra_specific_non_vulnerable_versions)).toBe(
          true
        );
      }

      if (vuln.only_for_path_ends_with !== undefined && vuln.only_for_path_ends_with !== null) {
        expect(typeof vuln.only_for_path_ends_with).toBe("string");
      }

      if (vuln.unaffected_distros !== undefined && vuln.unaffected_distros !== null) {
        expect(Array.isArray(vuln.unaffected_distros)).toBe(true);
      }

      if (vuln.simplify_version_if_has_patch_part !== undefined && vuln.simplify_version_if_has_patch_part !== null) {
        expect(typeof vuln.simplify_version_if_has_patch_part).toBe("boolean");
      }

      if (vuln.allow_patch_part_transformation !== undefined && vuln.allow_patch_part_transformation !== null) {
        expect(typeof vuln.allow_patch_part_transformation).toBe("boolean");
      }

      if (vuln.version_type_hint !== undefined && vuln.version_type_hint !== null) {
        expect(typeof vuln.version_type_hint).toBe("string");
        expect(['semver', 'dpkg']).toContain(vuln.version_type_hint);
      }

      if (vuln.reporter !== undefined && vuln.reporter !== null) {
        expect(typeof vuln.reporter).toBe("string");
      }

      if (vuln.language.toLowerCase() === "java") {
        expect(typeof vuln.org_name).toBe("string");
      }

      if (vuln.language.toLowerCase() === "js") {
        expect(vuln.package_name).toBe(vuln.package_name.toLowerCase());
      }

      if (vuln.vulnerable_ranges !== null) {
        if (!Array.isArray(vuln.vulnerable_ranges)) {
          expect(vuln.vulnerable_ranges).toBe("*");
        } else {
          expect(Array.isArray(vuln.vulnerable_ranges)).toBe(true);
          for(const range of vuln.vulnerable_ranges) {
            // should be array of arrays
            expect(Array.isArray(range)).toBe(true);
            expect(range.length).toBe(2);
            //check if range correct
            versionVulnLo = range[0];
            versionVulnUp = range[1];

            if(vuln.allow_patch_part_transformation === true){
              versionVulnLo = rewriteVersionToMakeItComparable(versionVulnLo);
              versionVulnUp = rewriteVersionToMakeItComparable(versionVulnUp);
            }

            if (version_compare(versionVulnLo, versionVulnUp) < 0) {
              throw new Error(versionVulnLo + " is not smaller than or equal to " + versionVulnUp);
            }
          }

          for(let i = 0; i < vuln.patch_versions.length; i++) {
            versionFixed =  vuln.patch_versions[i];
            versionVulnLo = vuln.vulnerable_ranges[i][0];
            versionVulnUp = vuln.vulnerable_ranges[i][1];

            if(vuln.allow_patch_part_transformation === true){
              versionFixed = rewriteVersionToMakeItComparable(versionFixed);
              versionVulnLo = rewriteVersionToMakeItComparable(versionVulnLo);
              versionVulnUp = rewriteVersionToMakeItComparable(versionVulnUp);
            }

            if (isVersionOutsideRange(versionFixed, versionVulnLo, versionVulnUp) === false) {
              throw new Error("Patch version cannot be inside vulnerable range: " + versionFixed + " - " + versionVulnLo + " - " + versionVulnUp);
            }
          }
        }
      }
    }
  });

  test("Valid languages", () => {
    const validLanguages = [
      "js",
      "python",
      "ruby",
      "java",
      "php",
      "go",
      "dotnet",
      "swift",
      "rust",
      "dart",
      "elixir",
      "os",
      "r",
      "c++",
    ];

    const languages = listAllLanguages(vulnerabilities);
    languages.forEach((language) => {
      expect(validLanguages).toContain(language.toLowerCase());
    });
  });

  test("Valid severity_class", () => {
    const severity_classes = ["LOW", "MEDIUM", "HIGH", "CRITICAL"];
    for (const [filename, vuln] of Object.entries(vulnerabilities)) {
      expect(severity_classes).toContain(vuln.severity_class);
    }
  });

  test("No duplicate vulnerability IDs", () => {
    const ids = listAllIds(vulnerabilities);
    expect(new Set(ids).size).toBe(ids.length);
  });

  test("Only JS vulnerabilities can start with '@'", () => {
    for (const vuln of Object.values(vulnerabilities)) {
      if (vuln.language.toLowerCase() !== "js") {
        expect(vuln.package_name.startsWith("@")).toBe(false);
      }
    }
  });
});


function rewriteVersionToMakeItComparable(version)
{
    // in some cases we have versions like 2.4.6-p12, 2.4.6-p16, 2.4.6-p18, 2.4.6-p20
    // the -p is actually a deeper patch version, so we'll act as if it's a, what we call, "minipatch"
    // e.g. 2.4.6-p12 -> 2.4.6.12
    if(version.match(/^\d+\.\d+\.\d+-p\d+$/)){
        version = version.replace('-p', '.');
    }

    return version;
}
